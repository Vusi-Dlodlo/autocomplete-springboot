        <div class="relative">
            <input 
                type="text" 
                id="searchInput" 
                placeholder="Search for items..." 
                class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            >
            <button 
                id="searchButton" 
                class="absolute right-2 top-1/2 transform -translate-y-1/2 bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg transition duration-200"
            >
                Search
            </button>
        </div>
    </div>
</div>

<!-- Modal Overlay -->
<div id="modalOverlay" class="modal-overlay fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
    <!-- Modal Content -->
    <div id="modalContent" class="modal-content bg-white rounded-xl shadow-xl w-full max-w-4xl mx-4 overflow-hidden">
        <!-- Modal Header -->
        <div class="bg-gradient-to-r from-blue-600 to-indigo-700 px-6 py-4 flex justify-between items-center">
            <h3 class="text-xl font-bold text-white">Search Results</h3>
            <button id="closeModal" class="text-white hover:text-gray-200 focus:outline-none">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                </svg>
            </button>
        </div>
        
        <!-- Loading Spinner -->
        <div id="loadingSpinner" class="py-20 flex justify-center items-center">
            <div class="spinner w-12 h-12 border-4 border-gray-200 rounded-full"></div>
        </div>
        
        <!-- Results Table -->
        <div id="resultsContainer" class="p-6 hidden">
            <div class="overflow-x-auto">
                <table class="min-w-full bg-white">
                    <thead>
                        <tr class="bg-gray-100 border-b">
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-600 uppercase tracking-wider">Name</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-600 uppercase tracking-wider">Description</th>
                            <th class="px-6 py-3 text-left text-xs font-medium text-gray-600 uppercase tracking-wider">Owner</th>
                        </tr>
                    </thead>
                    <tbody id="resultsTableBody">
                        <!-- Table rows will be inserted here dynamically using the template -->
                    </tbody>
                </table>
            </div>
            
            <!-- Row Template - This will be cloned for each result -->
            <template id="rowTemplate">
                <tr class="border-b hover:bg-gray-50">
                    <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900 item-name"></td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500 item-description"></td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500 item-owner"></td>
                </tr>
            </template>
            
            <!-- No Results Message -->
            <div id="noResultsMessage" class="hidden py-10 text-center text-gray-500">
                No matching items found.
            </div>
            
            <!-- Pagination Controls -->
            <div id="paginationContainer" class="mt-6 flex items-center justify-between border-t border-gray-200 pt-4">
                <div class="flex items-center text-sm text-gray-700">
                    <span id="paginationInfo">Showing <span id="startItem">1</span> to <span id="endItem">100</span> of <span id="totalItems">0</span> results</span>
                </div>
                <div class="flex space-x-2">
                    <button id="prevPageBtn" class="pagination-button px-4 py-2 bg-gray-200 text-gray-700 rounded-md disabled:opacity-50 disabled:cursor-not-allowed">
                        Previous
                    </button>
                    <div id="pageNumbers" class="flex space-x-1">
                        <!-- Page number template -->
                        <template id="pageButtonTemplate">
                            <button class="pagination-button w-10 h-10 flex items-center justify-center rounded-md bg-gray-200 text-gray-700 hover:bg-gray-300"></button>
                        </template>
                        <template id="ellipsisTemplate">
                            <span class="w-10 h-10 flex items-center justify-center text-gray-500">...</span>
                        </template>
                        <!-- Page numbers will be inserted here dynamically -->
                    </div>
                    <button id="nextPageBtn" class="pagination-button px-4 py-2 bg-gray-200 text-gray-700 rounded-md disabled:opacity-50 disabled:cursor-not-allowed">
                        Next
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        const searchInput = document.getElementById('searchInput');
        const searchButton = document.getElementById('searchButton');
        const modalOverlay = document.getElementById('modalOverlay');
        const modalContent = document.getElementById('modalContent');
        const closeModal = document.getElementById('closeModal');
        const loadingSpinner = document.getElementById('loadingSpinner');
        const resultsContainer = document.getElementById('resultsContainer');
        const resultsTableBody = document.getElementById('resultsTableBody');
        const rowTemplate = document.getElementById('rowTemplate');
        const noResultsMessage = document.getElementById('noResultsMessage');
        const paginationContainer = document.getElementById('paginationContainer');
        const prevPageBtn = document.getElementById('prevPageBtn');
        const nextPageBtn = document.getElementById('nextPageBtn');
        const pageNumbers = document.getElementById('pageNumbers');
        const pageButtonTemplate = document.getElementById('pageButtonTemplate');
        const ellipsisTemplate = document.getElementById('ellipsisTemplate');
        const startItem = document.getElementById('startItem');
        const endItem = document.getElementById('endItem');
        const totalItems = document.getElementById('totalItems');
        
        // Pagination state
        const state = {
            currentPage: 1,
            itemsPerPage: 100,
            totalPages: 1,
            allResults: [],
            searchTerm: ''
        };
        
        // API configuration - REPLACE THESE VALUES WITH YOUR ACTUAL API DETAILS
        const API_CONFIG = {
            // Replace with your actual API endpoint
            url: 'https://api.example.com/search',
            // Method for the API call
            method: 'GET',
            // Headers to include in the request
            headers: {
                'Content-Type': 'application/json',
                // Add any authentication headers if needed
                // 'Authorization': 'Bearer YOUR_API_TOKEN'
            },
            // Query parameter name for the search term
            searchParam: 'query',
            // Query parameter for pagination (if your API supports it)
            pageParam: 'page',
            pageSizeParam: 'pageSize',
            // Response mapping - adjust these based on your API response structure
            responseMapping: {
                // The property in the response that contains the array of results
                resultsArray: 'items',
                // The property in the response that contains the total count (if available)
                totalCount: 'totalCount',
                // The properties in each result item that map to our display fields
                nameField: 'name',
                descriptionField: 'description',
                ownerField: 'owner'
            }
        };
        
        // Function to fetch data from the API
        async function fetchItemsFromAPI(searchTerm, page = 1) {
            try {
                // Build query parameters
                const queryParams = new URLSearchParams();
                queryParams.append(API_CONFIG.searchParam, searchTerm);
                
                // Add pagination parameters if your API supports server-side pagination
                queryParams.append(API_CONFIG.pageParam, page);
                queryParams.append(API_CONFIG.pageSizeParam, state.itemsPerPage);
                
                // Build the full URL with query parameters
                const url = `${API_CONFIG.url}?${queryParams.toString()}`;
                
                // Make the API request
                const response = await fetch(url, {
                    method: API_CONFIG.method,
                    headers: API_CONFIG.headers
                });
                
                // Check if the request was successful
                if (!response.ok) {
                    throw new Error(`API request failed with status ${response.status}`);
                }
                
                // Parse the JSON response
                const data = await response.json();
                
                // Extract the results array and total count based on the response mapping
                const results = data[API_CONFIG.responseMapping.resultsArray] || [];
                const totalCount = data[API_CONFIG.responseMapping.totalCount] || results.length;
                
                // Map the API response to our internal format
                const mappedResults = results.map(item => ({
                    name: item[API_CONFIG.responseMapping.nameField],
                    description: item[API_CONFIG.responseMapping.descriptionField],
                    owner: item[API_CONFIG.responseMapping.ownerField]
                }));
                
                return {
                    results: mappedResults,
                    totalCount: totalCount
                };
            } catch (error) {
                console.error('Error fetching data from API:', error);
                throw error;
            }
        }
        
        function openModal() {
            modalOverlay.classList.remove('hidden');
            setTimeout(() => {
                modalOverlay.classList.add('active');
                modalContent.classList.add('active');
            }, 10);
        }
        
        function closeModalHandler() {
            modalOverlay.classList.remove('active');
            modalContent.classList.remove('active');
            setTimeout(() => {
                modalOverlay.classList.add('hidden');
                // Reset state
                loadingSpinner.classList.remove('hidden');
                resultsContainer.classList.add('hidden');
                state.currentPage = 1;
            }, 300);
        }
        
        function updatePaginationInfo() {
            const start = (state.currentPage - 1) * state.itemsPerPage + 1;
            const end = Math.min(state.currentPage * state.itemsPerPage, state.allResults.length);
            
            startItem.textContent = start;
            endItem.textContent = end;
            totalItems.textContent = state.allResults.length;
            
            // Update pagination buttons state
            prevPageBtn.disabled = state.currentPage === 1;
            nextPageBtn.disabled = state.currentPage === state.totalPages;
            
            // Generate page number buttons
            renderPageNumbers();
        }
        
        function renderPageNumbers() {
            pageNumbers.innerHTML = '';
            
            // Determine which page numbers to show
            let startPage = Math.max(1, state.currentPage - 2);
            let endPage = Math.min(state.totalPages, state.currentPage + 2);
            
            // Always show at least 5 pages if available
            if (endPage - startPage < 4) {
                if (startPage === 1) {
                    endPage = Math.min(5, state.totalPages);
                } else if (endPage === state.totalPages) {
                    startPage = Math.max(1, state.totalPages - 4);
                }
            }
            
            // Add first page and ellipsis if needed
            if (startPage > 1) {
                addPageButton(1);
                if (startPage > 2) {
                    addEllipsis();
                }
            }
            
            // Add page numbers
            for (let i = startPage; i <= endPage; i++) {
                addPageButton(i);
            }
            
            // Add last page and ellipsis if needed
            if (endPage < state.totalPages) {
                if (endPage < state.totalPages - 1) {
                    addEllipsis();
                }
                addPageButton(state.totalPages);
            }
        }
        
        function addPageButton(pageNum) {
            const clone = pageButtonTemplate.content.cloneNode(true);
            const button = clone.querySelector('button');
            button.textContent = pageNum;
            
            if (pageNum === state.currentPage) {
                button.classList.remove('bg-gray-200', 'text-gray-700', 'hover:bg-gray-300');
                button.classList.add('bg-blue-600', 'text-white');
            }
            
            button.addEventListener('click', () => goToPage(pageNum));
            pageNumbers.appendChild(button);
        }
        
        function addEllipsis() {
            const clone = ellipsisTemplate.content.cloneNode(true);
            pageNumbers.appendChild(clone);
        }
        
        function goToPage(pageNum) {
            if (pageNum < 1 || pageNum > state.totalPages || pageNum === state.currentPage) {
                return;
            }
            
            state.currentPage = pageNum;
            
            // If your API supports server-side pagination, you might want to fetch new data here
            // For this example, we're assuming client-side pagination with all results already loaded
            renderTableData();
            updatePaginationInfo();
        }
        
        function renderTableData() {
            const startIndex = (state.currentPage - 1) * state.itemsPerPage;
            const endIndex = Math.min(startIndex + state.itemsPerPage, state.allResults.length);
            const currentPageData = state.allResults.slice(startIndex, endIndex);
            
            // Clear the table body
            resultsTableBody.innerHTML = '';
            
            // Use the template to create rows
            currentPageData.forEach(item => {
                const clone = rowTemplate.content.cloneNode(true);
                
                // Find elements by their class names and set content
                clone.querySelector('.item-name').textContent = item.name;
                clone.querySelector('.item-description').textContent = item.description;
                clone.querySelector('.item-owner').textContent = item.owner;
                
                // Append the new row to the table body
                resultsTableBody.appendChild(clone);
            });
        }
        
        async function performSearch() {
            const searchTerm = searchInput.value.trim();
            state.searchTerm = searchTerm;
            
            if (searchTerm === '') {
                // Optional: Show validation message
                searchInput.classList.add('ring-2', 'ring-red-500');
                setTimeout(() => {
                    searchInput.classList.remove('ring-2', 'ring-red-500');
                }, 2000);
                return;
            }
            
            // Show modal with loading state
            openModal();
            loadingSpinner.classList.remove('hidden');
            resultsContainer.classList.add('hidden');
            
            try {
                // Fetch data from API
                const apiResponse = await fetchItemsFromAPI(searchTerm);
                
                // Store all results and update pagination state
                state.allResults = apiResponse.results;
                state.totalPages = Math.ceil(apiResponse.totalCount / state.itemsPerPage);
                state.currentPage = 1;
                
                // Hide loading spinner
                loadingSpinner.classList.add('hidden');
                resultsContainer.classList.remove('hidden');
                
                // Update table with results
                if (state.allResults.length > 0) {
                    noResultsMessage.classList.add('hidden');
                    paginationContainer.classList.remove('hidden');
                    renderTableData();
                    updatePaginationInfo();
                } else {
                    noResultsMessage.classList.remove('hidden');
                    paginationContainer.classList.add('hidden');
                }
            } catch (error) {
                console.error('Error fetching data:', error);
                loadingSpinner.classList.add('hidden');
                resultsContainer.classList.remove('hidden');
                noResultsMessage.textContent = 'An error occurred while fetching data.';
                noResultsMessage.classList.remove('hidden');
                paginationContainer.classList.add('hidden');
            }
        }
        
        // For testing purposes only - replace this with your actual API implementation
        // This simulates an API response for development/testing
        async function mockFetchForTesting(searchTerm) {
            return new Promise((resolve) => {
                setTimeout(() => {
                    // Generate mock data
                    const mockData = [];
                    for (let i = 0; i < 350; i++) {
                        mockData.push({
                            name: `Item ${i + 1} ${searchTerm ? `matching "${searchTerm}"` : ''}`,
                            description: `Description for item ${i + 1}`,
                            owner: `Owner ${(i % 5) + 1}`
                        });
                    }
                    
                    resolve({
                        results: mockData,
                        totalCount: mockData.length
                    });
                }, 800);
            });
        }
        
        // Event Listeners
        searchButton.addEventListener('click', performSearch);
        searchInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                performSearch();
            }
        });
        
        prevPageBtn.addEventListener('click', () => goToPage(state.currentPage - 1));
        nextPageBtn.addEventListener('click', () => goToPage(state.currentPage + 1));
        
        closeModal.addEventListener('click', closeModalHandler);
        modalOverlay.addEventListener('click', function(e) {
            if (e.target === modalOverlay) {
                closeModalHandler();
            }
        });
        
        // IMPORTANT: For development/testing only
        // Replace fetchItemsFromAPI with mockFetchForTesting in the performSearch function
        // to test without an actual API endpoint
        // In production, use the real fetchItemsFromAPI function
    });
</script>
